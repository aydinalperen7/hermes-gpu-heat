from numba import cudafrom math import sin, pi@cuda.jitdef mv_level3_dirichlet(    nx, ny, nz,    v, result,           # in/out    hixsq, hiysq, hizsq,    dt05,    n2,    u0,                  # unused except at Dirichlet boundaries; kept for parity #REMOVE    hz):    """    Level 3 (Dirichlet) matrix-vector product for implicit scheme.    Boundary nodes return identity (result = v).    Top closure uses -2*hz*n2*vC.    """    idxx = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x    if idxx >= nx * ny * nz:        return    i = idxx % nx    j = (idxx // nx) % ny    k = idxx // (nx * ny)    if i == 0 or i == nx - 1 or j == 0 or j == ny - 1 or k == 0:        result[idxx] = v[idxx]        return    O = idxx + 1; I = idxx - 1; R = idxx + nx; L = idxx - nx; T = idxx + nx * ny; B = idxx - nx * ny    uC = v[idxx]    uI = v[I]; uO = v[O]; uR = v[R]; uL = v[L]; uB = v[B]    uT = v[T] if k < nz - 1 else (uB - 2.0 * hz * n2 * uC)    dx = -(uO + uI) * hixsq * dt05    dy = -(uR + uL) * hiysq * dt05    dz = -(uT + uB) * hizsq * dt05    p1 = (2.0 * uC * (hixsq + hiysq + hizsq)) * dt05 + uC    result[idxx] = dx + dy + dz + p1@cuda.jitdef mv_level12_neumann(    nx, ny, nz,    v, result,       # in/out    hixsq, hiysq, hizsq,    dt05,    n2, iSte,    u_phase,         # for latent term    hz):    """    Levels 1â€“2 (Neumann) matrix-vector product.    """        idxx = cuda.blockIdx.x * cuda.blockDim.x + cuda.threadIdx.x    if idxx >= nx * ny * nz:        return    i = idxx % nx    j = (idxx // nx) % ny    k = idxx // (nx * ny)    O = idxx + 1; I = idxx - 1; R = idxx + nx; L = idxx - nx; T = idxx + nx * ny; B = idxx - nx * ny    vC = v[idxx]    if (0 < i < nx - 1) and (0 < j < ny - 1) and (0 < k < nz - 1):        uI = v[I]; uO = v[O]; uR = v[R]; uL = v[L]; uT = v[T]; uB = v[B]            else:        if k == nz - 1:            uB = v[B]            uT = uB - 2.0 * hz * n2 * vC        elif k == 0:            uT = v[T]; uB = uT        else:            uT = v[T]; uB = v[B]        if j == ny - 1:            uL = v[L]; uR = uL        elif j == 0:            uR = v[R]; uL = uR        else:            uR = v[R]; uL = v[L]        if i == nx - 1:            uI = v[I]; uO = uI        elif i == 0:            uO = v[O]; uI = uO        else:            uO = v[O]; uI = v[I]    dx = -(uO + uI) * hixsq * dt05    dy = -(uR + uL) * hiysq * dt05    dz = -(uT + uB) * hizsq * dt05    if (u_phase[idxx] > 0.0) and (u_phase[idxx] < 1.0):        p1 = (2.0 * vC * (hixsq + hiysq + hizsq)) * dt05 + vC + (0.5 * pi * iSte * sin(pi * u_phase[idxx]) * vC)    else:        p1 = (2.0 * vC * (hixsq + hiysq + hizsq)) * dt05 + vC    result[idxx] = dx + dy + dz + p1