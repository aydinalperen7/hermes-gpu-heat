from __future__ import annotationsimport configparserimport mathimport refrom dataclasses import dataclassfrom pathlib import Pathfrom typing import Optional, Tuple, Dict, Any# -----------------------------# Parsing helpers (stdlib only)# -----------------------------# length units (SI)_SI = {"m": 1.0, "mm": 1e-3, "um": 1e-6, "µm": 1e-6, "nm": 1e-9}_num_unit = re.compile(r"^\s*([+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\s*([a-zA-Zµ]*)\s*$")def _parse_length_atom(s: str) -> float:    m = _num_unit.match(s)    if not m:        raise ValueError(f"Cannot parse length token: {s!r}")    num = float(m.group(1))    unit = (m.group(2) or "m").strip()    if unit not in _SI:        raise ValueError(f"Unknown unit {unit!r} in {s!r}; allowed {list(_SI)}")    return num * _SI[unit]def parse_length_expr(s: str) -> float:    """    Supports: "96 * 50um", "12*50 um", "0.001", "1e-4m"    Returns meters (float).    """    parts = [p.strip() for p in s.split("*")]    val = 1.0    for p in parts:        if p:            val *= _parse_length_atom(p)    return valdef parse_length_triplet(s: str) -> Tuple[float, float, float]:    # supports: "4um, 5um, 6um" or "4um 5um 6um" or "4um,5um,6um"    raw = s.replace(",", " ").split()    if len(raw) != 3:        raise ValueError(f"Expected 3 values for anisotropic h, got: {s!r}")    hx, hy, hz = (parse_length_expr(tok) for tok in raw)    return float(hx), float(hy), float(hz)def parse_float(s: str) -> float:    return float(str(s).strip())def parse_bool(s: str) -> bool:    return str(s).strip().lower() in {"1", "true", "yes", "y", "on"}def parse_temperature(s: str) -> float:    """Accepts '25C', '298K', or unitless (assumed K). Returns Kelvin."""    t = str(s).strip()    if not t:        raise ValueError("Empty temperature string.")    low = t.lower()    if low.endswith("c"):        return float(t[:-1]) + 273.0    if low.endswith("k"):        return float(t[:-1])    return float(t)  # assume Kelvin if unitlessdef parse_time_expr(s: str) -> float:    """Accepts '12ms', '200us', '0.1s', or unitless seconds."""    t = str(s).strip().lower()    if t.endswith("ms"): return float(t[:-2]) * 1e-3    if t.endswith("us"): return float(t[:-2]) * 1e-6    if t.endswith("s"):  return float(t[:-1])    return float(t)# -----------------------------# Dataclasses# -----------------------------@dataclassclass MaterialSpec:    name: str = "316L"   # informational    K: Optional[float] = None    rho: Optional[float] = None    Cp: Optional[float] = None    Lf: Optional[float] = None    A: Optional[float] = None    T0: Optional[float] = None  # Kelvin    Ts: Optional[float] = None  # Kelvin    Tl: Optional[float] = None  # Kelvin    hc: Optional[float] = None    epsilon: Optional[float] = None    sigma: Optional[float] = None    def to_override_dict(self) -> Dict[str, Any]:        d = {            "K": self.K, "rho": self.rho, "Cp": self.Cp, "Lf": self.Lf, "A": self.A,            "T0": self.T0, "Ts": self.Ts, "Tl": self.Tl,            "hc": self.hc, "epsilon": self.epsilon, "sigma": self.sigma,        }        return {k: v for k, v in d.items() if v is not None}@dataclassclass LaserInputs:    Q: float              # W    x_span_m: float       # beam radius (m)    v: float              #  velocity    x00_initial: float    # m (or code units)    y00_initial: float    t_spot_on: float      # seconds@dataclassclass GridSpec:    # physical lengths (meters)    lxd: float    lyd: float    lzd: float    # resolution options (choose ONE):    h_factor: Optional[float] = None                   # isotropic: h = base_h / h_factor    h_tuple: Optional[Tuple[float, float, float]] = None  # anisotropic (hx, hy, hz) in meters    nx: Optional[int] = None    ny: Optional[int] = None    nz: Optional[int] = None    # finalized fields (filled in by _finalize_resolution):    hx: Optional[float] = None    hy: Optional[float] = None    hz: Optional[float] = None@dataclassclass SolverSpec:    cg_tol_level1: float = 1e-6    cg_tol_level2: float = 1e-5    cg_tol_level3: float = 1e-4    cg_max_iter_level1: int = 1000    cg_max_iter_level2: int = 1000    cg_max_iter_level3: int = 1000@dataclassclass OutputSpec:    dir: str = "outputs"    save_arrays: bool = True    tag: str = "run"    format: str = "npy"     # "npy" or "npz"    final_only: bool = True    save_stride: int = 0    save_steps: Tuple[int, ...] = ()    compress: bool = True    @dataclassclass MovementSpec:    x: int = 0    y: int = 0@dataclassclass TimeSpec:    # seconds; one of end_time_s or scan_length_m should be provided    end_time_s: Optional[float] = None    scan_length_m: Optional[float] = None    dt: Optional[float] = None      # seconds (optional)    CFL: Optional[float] = None     # nondimensional CFL (optional)@dataclassclass LayerSpec:    num_layers: int = 1    layer_thickness: float = 50e-6   # meters@dataclassclass RunConfig:    float_type_str: str    laser: LaserInputs    level1: GridSpec    level2: GridSpec    level3: GridSpec    time: TimeSpec    output: OutputSpec    material: MaterialSpec    movement: MovementSpec      layers: LayerSpec    solver: SolverSpec        # -----------------------------# Loader# -----------------------------def load_config(path: str | Path) -> RunConfig:    cfg = configparser.ConfigParser(inline_comment_prefixes=("#", ";"))    with open(path, "r") as f:        cfg.read_file(f)    # simulation (optional)    sim = cfg["simulation"] if "simulation" in cfg else {}    float_type_str = sim.get("float_type", "float32").strip()    tag = sim.get("tag", "run").strip()    # laser (t_spot_on optional)    las = cfg["laser"]    laser = LaserInputs(        Q = parse_float(las["Q"]),        x_span_m = parse_length_expr(las["x_span"]),        v = parse_float(las["v"]),        x00_initial = parse_float(las["x00_initial"]),        y00_initial = parse_float(las["y00_initial"]),        t_spot_on = parse_time_expr(las.get("t_spot_on", "0")),    )            # time (optional)    tim = cfg["time"] if "time" in cfg else {}    time = TimeSpec(        end_time_s   = parse_time_expr(tim["end_time"])   if "end_time"   in tim else None,        scan_length_m= parse_length_expr(tim["scan_length"]) if "scan_length" in tim else None,        dt           = parse_time_expr(tim["dt"])         if "dt"         in tim else None,        CFL          = float(tim["CFL"])                  if "CFL"        in tim else None,    )        # grids    def read_grid(sec: str) -> GridSpec:        g = cfg[sec]        def opt(key, fn):            return fn(g[key]) if key in g else None        lxd = parse_length_expr(g["lxd"])        lyd = parse_length_expr(g["lyd"])        lzd = parse_length_expr(g["lzd"])        h_tuple = None        if "h" in g:            h_tuple = parse_length_triplet(g["h"])  # must be 3 entries        return GridSpec(            lxd=lxd, lyd=lyd, lzd=lzd,            h_factor=opt("h_factor", float),            h_tuple=h_tuple,            nx=opt("nx", int), ny=opt("ny", int), nz=opt("nz", int),        )    level3 = read_grid("grid.level3")    level2 = read_grid("grid.level2")    level1 = read_grid("grid.level1")            # solver (optional)    if "solver" in cfg:        s = cfg["solver"]        solver = SolverSpec(            cg_tol_level1=float(s.get("cg_tol_level1", 1e-6)),            cg_tol_level2=float(s.get("cg_tol_level2", 1e-5)),            cg_tol_level3=float(s.get("cg_tol_level3", 1e-4)),            cg_max_iter_level1=int(s.get("cg_max_iter_level1", 1000)),            cg_max_iter_level2=int(s.get("cg_max_iter_level2", 1000)),            cg_max_iter_level3=int(s.get("cg_max_iter_level3", 1000)),        )    else:        solver = SolverSpec()    # output    out = cfg["output"] if "output" in cfg else {}    def _parse_steps(s: str) -> Tuple[int, ...]:        s = (s or "").strip()        if not s:            return ()        return tuple(int(tok.strip()) for tok in s.replace(";", ",").split(",") if tok.strip())    output = OutputSpec(        dir = out.get("dir", "outputs"),        save_arrays = parse_bool(out.get("save_arrays", "true")),        tag = sim.get("tag", out.get("tag", "run")),        format = out.get("format", "npy").strip().lower(),  # "npy" or "npz"        final_only = parse_bool(out.get("final_only", "true")),        save_stride = int(out.get("save_stride", "0")),        save_steps = _parse_steps(out.get("save_steps", "")),        compress = parse_bool(out.get("compress", "true")),    )    # material (optional overrides)    if "material" in cfg:        m = cfg["material"]        material = MaterialSpec(            name = m.get("name", "316L"),            K = float(m["K"]) if "K" in m else None,            rho = float(m["rho"]) if "rho" in m else None,            Cp = float(m["Cp"]) if "Cp" in m else None,            Lf = float(m["Lf"]) if "Lf" in m else None,            A = float(m["A"]) if "A" in m else None,            T0 = parse_temperature(m["T0"]) if "T0" in m else None,            Ts = parse_temperature(m["Ts"]) if "Ts" in m else None,            Tl = parse_temperature(m["Tl"]) if "Tl" in m else None,            hc = float(m["hc"]) if "hc" in m else None,            epsilon = float(m["epsilon"]) if "epsilon" in m else None,            sigma = float(m["sigma"]) if "sigma" in m else None,        )    else:        material = MaterialSpec()  # keep defaults (316L)            # movement    if "movement" in cfg:        mv = cfg["movement"]        mx = int(mv.get("x", "0"))        my = int(mv.get("y", "0"))        if mx not in (-1, 0, 1) or my not in (-1, 0, 1):            raise ValueError("[movement] x and y must be one of {-1,0,1}.")        movement = MovementSpec(x=mx, y=my)    else:        movement = MovementSpec()            # layers    if "layers" in cfg:        lay = cfg["layers"]        layers = LayerSpec(            num_layers = int(lay.get("num_layers", "1")),            layer_thickness = parse_length_expr(lay.get("layer_thickness", "50um")),        )    else:        layers = LayerSpec()    rc = RunConfig(        float_type_str=float_type_str,        laser=laser,        level1=level1, level2=level2, level3=level3,        time=time,        output=output,        material=material,        movement=movement,        layers=layers,           solver=solver,    )    _finalize_resolution(rc)    return rc# -----------------------------# Resolution finalization# -----------------------------def _finalize_resolution(rc: RunConfig) -> None:    """    Ensure each level has hx,hy,hz and nx,ny,nz.    Allowed per level (choose ONE):      - h_factor (isotropic, relative to level3.h)      - h = hx, hy, hz (tuple in meters)      - nx, ny, nz (explicit counts)    Level 3 must not use h_factor (no anchor); it must specify h (tuple) or nx/ny/nz.    Level 2/1 can use any of the three.    """    def complete_level3(level: GridSpec, name: str) -> None:        # spacing        if level.h_tuple is not None:            hx, hy, hz = level.h_tuple        elif all(v is not None for v in (level.nx, level.ny, level.nz)):            hx = level.lxd / max(level.nx, 1)            hy = level.lyd / max(level.ny, 1)            hz = level.lzd / max(level.nz, 1)        else:            raise ValueError(f"{name}: must specify 'h = hx,hy,hz' OR all of nx,ny,nz (h_factor not allowed).")        # counts        if level.nx is None: level.nx = max(1, math.ceil(level.lxd / hx))        if level.ny is None: level.ny = max(1, math.ceil(level.lyd / hy))        if level.nz is None: level.nz = max(1, math.ceil(level.lzd / hz))        level.hx, level.hy, level.hz = float(hx), float(hy), float(hz)        level.h_tuple = (level.hx, level.hy, level.hz)    def complete(level: GridSpec, name: str, anchor_h: float) -> None:        # spacing selection        if level.h_tuple is not None:            hx, hy, hz = level.h_tuple        elif level.h_factor is not None:            if anchor_h is None:                raise ValueError(f"{name}: h_factor requires base level spacing.")            h_iso = anchor_h / float(level.h_factor)            hx = hy = hz = h_iso        elif all(v is not None for v in (level.nx, level.ny, level.nz)):            hx = level.lxd / max(level.nx, 1)            hy = level.lyd / max(level.ny, 1)            hz = level.lzd / max(level.nz, 1)        else:            raise ValueError(f"{name}: choose ONE of h_factor, 'h = hx,hy,hz', or nx/ny/nz.")        # counts if missing        if level.nx is None: level.nx = max(1, math.ceil(level.lxd / hx))        if level.ny is None: level.ny = max(1, math.ceil(level.lyd / hy))        if level.nz is None: level.nz = max(1, math.ceil(level.lzd / hz))        level.hx, level.hy, level.hz = float(hx), float(hy), float(hz)        level.h_tuple = (level.hx, level.hy, level.hz)    # finalize level 3 first (anchor)    complete_level3(rc.level3, "grid.level3")    anchor_h = rc.level3.hx  # assume isotropic anchor if h_factor used downstream    # finalize level 2 and level 1 using anchor_h for h_factor case    complete(rc.level2, "grid.level2", anchor_h)    complete(rc.level1, "grid.level1", anchor_h)    