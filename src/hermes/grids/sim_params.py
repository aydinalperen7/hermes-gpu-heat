import numpy as np__all__ = ["simu_parameter3d", "init_level3_outer"]  # add init_inner_level?class simu_parameter3d:    """    simulation params (outer/level-3).    """    def __init__(self, p, lxd, lyd, lzd, h_m, dt, sol_max_override):                # original dimensional length and non-dimensionalization        self.lx = lxd / p.len_scale        self.ly = lyd / p.len_scale        self.lz = lzd / p.len_scale           self.h = h_m / p.len_scale        self.dt = dt                self.nx =  int(self.lx/self.h) + 1        self.ny =  int(self.ly/self.h) + 1        self.nz =  int(self.lz/self.h) + 1        self.lz = (self.nz - 1) * self.h                # self.t_end = 4* p.t_spot_on         # self.sol_max = int(( (self.t_end) / p.time_scale ) / self.dt) * 8        self.sol_max = max(int(sol_max_override), 1)        self.t_end = (self.sol_max - 1) * dt                        self.lx = (self.nx - 1) * self.h        self.ly = (self.ny - 1) * self.h        self.lz = (self.nz - 1) * self.hdef init_level3_outer(phys, float_type,  lxd, lyd, lzd, h_m, dt, xp, target_step):    """    Build the outer/level-3 arrays and constants.    xp: numpy or cupy module (pass cupy as `xp` in GPU code).    """    sol_max_override = (target_step + 1)    sp = simu_parameter3d(phys, lxd, lyd, lzd, h_m, dt, sol_max_override)    # grid    x_lin = xp.linspace(-sp.lx/2,  sp.lx/2,  num=sp.nx, dtype=float_type)    y_lin = xp.linspace(-sp.ly/2,  sp.ly/2,  num=sp.ny, dtype=float_type)    z_lin = xp.linspace(-sp.lz, 0,         num=sp.nz, dtype=float_type)    x_lin0 = x_lin.copy()    y_lin0 = y_lin.copy()    z_lin0 = z_lin.copy()    # time    dt_lin = float_type(sp.dt)    # t_vals_lin = xp.linspace(0, (sp.sol_max - 1) * dt_lin, sp.sol_max, dtype=float_type)    # solver fields    u0 = float_type((phys.T0 - phys.Ts) / phys.deltaT)    size = sp.nx * sp.ny * sp.nz    u_lin     = u0 * xp.ones(size, dtype=float_type)    u_new_lin = u0 * xp.ones(size, dtype=float_type)    b_lin     = xp.ones(size, dtype=float_type)    # constants    h_lin = float_type(sp.h)    h_linisq  = float_type(1.0 / (h_lin**2))    dt_lin05 = float_type(dt_lin * 0.5)    out = dict(        sp=sp,        x_lin=x_lin, y_lin=y_lin, z_lin=z_lin,        x_lin0=x_lin0, y_lin0=y_lin0, z_lin0=z_lin0,        dt_lin=dt_lin,        u_lin=u_lin, u_new_lin=u_new_lin, b_lin=b_lin,        h_lin=h_lin, h_linisq=h_linisq, dt_lin05=dt_lin05,        u0=u0,    )    return outdef init_inner_level(    outer,                 # dict from init_level3_outer(...)    x_span,                # nondimensional laser radius (code units)    *,    size=None,             # scalar or (sx,sy,sz) in code units; overrides size_factor    h_new=None,            # explicit grid spacings (hx, hy, hz); overrides h_factor    h_factor=4.0,          # default: hx=hy=hz = h_lin/h_factor  (L1=4, L2=2)    center=(0.0, 0.0),     # (x0, y0) box center in code units    z_end=None,            # top z of outer domain; default outer["z_lin"][-1]    float_type=None,    xp=None):    """    General inner-level initializer (works for Level 1, 2, ...).    Preserves your column-major layout and boundary slice construction.    Returns a dict with the same fields you already use (x_s, y_s, z_s, ...).    """    assert xp is not None and float_type is not None    sp      = outer["sp"]    x_lin   = outer["x_lin"]; y_lin = outer["y_lin"]; z_lin = outer["z_lin"]    h_lin   = outer["h_lin"]    u0      = outer["u0"]    x0, y0  = center    if z_end is None:        z_end = z_lin[-1]    # ----- box size -----    if size is None:        sx = sy = sz = 12.0 * float(5e-5)    else:        if isinstance(size, (list, tuple)):            sx, sy, sz = map(float, size)        else:            sx = sy = sz = float(size)    sx2, sy2  = sx/2.0, sy/2.0    # ----- select outer indices within box -----    eps = float(np.finfo(float_type).eps)    xx = xp.arange(sp.nx); yy = xp.arange(sp.ny); zz = xp.arange(sp.nz)    mask_x = (x_lin > x0 - sx2-eps) & (x_lin < x0 + sx2+eps)    mask_y = (y_lin > y0 - sy2-eps) & (y_lin < y0 + sy2+eps)    mask_z = (z_lin > z_end - sz-eps) & (z_lin < z_end+eps)    xs = xx[mask_x]; ys = yy[mask_y]; zs = zz[mask_z]    k_lowx, k_upx = int(xs[0]), int(xs[-1])    k_lowy, k_upy = int(ys[0]), int(ys[-1])    k_lowz, k_upz = int(zs[0]), int(z_lin.shape[0] - 1)        x_s_start, x_s_end = x_lin[k_lowx], x_lin[k_upx]    y_s_start, y_s_end = y_lin[k_lowy], y_lin[k_upy]    z_s_start, z_s_end = z_lin[k_lowz], z_lin[k_upz]    # ----- inner spacings -----    if h_new is None:        f = float(h_factor)        h_x = float_type(h_lin / f)        h_y = float_type(h_lin / f)        h_z = float_type(h_lin / f)    else:        hx, hy, hz = h_new        h_x = float_type(hx); h_y = float_type(hy); h_z = float_type(hz)    # sizes with your rounding rule    nx_s = int(xp.round((x_lin[k_upx] - x_lin[k_lowx]) / h_x) + 1)    ny_s = int(xp.round((y_lin[k_upy] - y_lin[k_lowy]) / h_y) + 1)    nz_s = int(xp.round((z_lin[k_upz] - z_lin[k_lowz]) / h_z) + 1)    nx_s2, ny_s2, nz_s2 = nx_s + 2, ny_s + 2, nz_s + 1    # ----- coordinates (core and padded) -----    x_s  = xp.linspace(x_s_start, x_s_end, num=nx_s,  dtype=float_type)    y_s  = xp.linspace(y_s_start, y_s_end, num=ny_s,  dtype=float_type)    z_s = xp.linspace(z_s_start,z_s_end, num = nz_s,  dtype=float_type)     x_s2 = xp.linspace(x_s_start - h_x, x_s_end + h_x, num=nx_s2, dtype=float_type)    y_s2 = xp.linspace(y_s_start - h_y, y_s_end + h_y, num=ny_s2, dtype=float_type)    z_s2 = xp.linspace(z_s_start-h_z, z_s_end, num = nz_s2,  dtype=float_type)     x_s0, y_s0, z_s0   = x_s.copy(), y_s.copy(), z_s.copy()    x_s20, y_s20, z_s20 = x_s2.copy(), y_s2.copy(), z_s2.copy()    # inverse spacings (+ squares)    h_ix = float_type(1.0) / h_x    h_iy = float_type(1.0) / h_y    h_iz = float_type(1.0) / h_z    h_ixsq = float_type(h_ix**2)    h_iysq = float_type(h_iy**2)    h_izsq = float_type(h_iz**2)    # ----- solver fields -----    size_core = nx_s * ny_s * nz_s    u_s      = u0 * xp.ones(size_core, dtype=float_type)    u_new_s  = u0 * xp.ones(size_core, dtype=float_type)    b_s      = xp.ones(size_core, dtype=float_type)    # ----- laser placeholders -----    Y_s, X_s = xp.meshgrid(y_s, x_s)    X_s0, Y_s0 = X_s.copy(), Y_s.copy()    qs_s = xp.zeros((nx_s, ny_s), dtype=float_type)    Zs2_xy_s = None  # fill by caller with gaussian2d    # ----- interpolation buffers -----    uinteold = xp.zeros(x_s2.shape[0] * y_s2.shape[0] * z_s2.shape[0], dtype=float_type)    uinte    = xp.zeros_like(uinteold)    # ----- BC arrays -----    p_r = xp.zeros(nx_s * nz_s, dtype=float_type)    p_l = xp.zeros(nx_s * nz_s, dtype=float_type)    p_b = xp.zeros(nx_s * ny_s, dtype=float_type)    p_o = xp.zeros(ny_s * nz_s, dtype=float_type)    p_i = xp.zeros(ny_s * nz_s, dtype=float_type)    p_r_old = xp.zeros_like(p_r)    p_l_old = xp.zeros_like(p_l)    p_b_old = xp.zeros_like(p_b)    p_o_old = xp.zeros_like(p_o)    p_i_old = xp.zeros_like(p_i)    # ----- Fortran-order face index slices -----    indices_3d2 = xp.arange(nx_s2 * ny_s2 * nz_s2).reshape([nx_s2, ny_s2, nz_s2], order="F")    slice_bc_right0  = indices_3d2[1:-1, -3, 1:]    slice_bc_left0   = indices_3d2[1:-1,  0, 1:]    slice_bc_in0     = indices_3d2[0,   1:-1, 1:]    slice_bc_out0    = indices_3d2[-3, 1:-1, 1:]    slice_bc_bottom0 = indices_3d2[1:-1, 1:-1, 0]    slice_bc_right0_1d  = slice_bc_right0.ravel(order="F")    slice_bc_left0_1d   = slice_bc_left0.ravel(order="F")    slice_bc_bottom0_1d = slice_bc_bottom0.ravel(order="F")    slice_bc_in0_1d     = slice_bc_in0.ravel(order="F")    slice_bc_out0_1d    = slice_bc_out0.ravel(order="F")    return dict(        # sizes / indices        nx_s=nx_s, ny_s=ny_s, nz_s=nz_s,        nx_s2=nx_s2, ny_s2=ny_s2, nz_s2=nz_s2,        # grids        x_s=x_s, y_s=y_s, z_s=z_s, x_s2=x_s2, y_s2=y_s2, z_s2=z_s2,        x_s0=x_s0, y_s0=y_s0, z_s0=z_s0, x_s20=x_s20, y_s20=y_s20, z_s20=z_s20,        # spacings        h_x_new=h_x, h_y_new=h_y, h_z_new=h_z,        h_ix_new=h_ix, h_iy_new=h_iy, h_iz_new=h_iz,        h_ix_newsq=h_ixsq, h_iy_newsq=h_iysq, h_iz_newsq=h_izsq,        # solver fields        u_s=u_s, u_new_s=u_new_s, b_s=b_s,        # laser placeholders        X_s=X_s, Y_s=Y_s, X_s0=X_s0, Y_s0=Y_s0, qs_s=qs_s, Zs2_xy_s=Zs2_xy_s,        # interpolation        uinteold=uinteold, uinte=uinte,        # BC arrays        p_r=p_r, p_l=p_l, p_b=p_b, p_o=p_o, p_i=p_i,        p_r_old=p_r_old, p_l_old=p_l_old, p_b_old=p_b_old, p_o_old=p_o_old, p_i_old=p_i_old,        # face index slices        indices_3d2=indices_3d2,        slice_bc_right0_1d=slice_bc_right0_1d,        slice_bc_left0_1d=slice_bc_left0_1d,        slice_bc_bottom0_1d=slice_bc_bottom0_1d,        slice_bc_in0_1d=slice_bc_in0_1d,        slice_bc_out0_1d=slice_bc_out0_1d,    )